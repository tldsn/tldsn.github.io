---
layout: post
title: git
categories: 工具
tags: git 命令
author: tldsn
---

* content
{:toc}


## 概念

* 工作目录、缓冲区、提交历史

* HEAD表示当前版本，也就是最新的提交,上一个版本就是HEAD^，上上一个版本就是HEAD^^

* HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。

## base

* `git init`　　创建新仓库　　

* `git status`　　查看状态　　


* `git log --pretty=oneline`　　提交历史　　
  
* `git reflog`　　命令历史　　
  
* `git diff HEAD -- readme.txt`　　查看工作区和版本库里面最新版本的区别

### 简单提交流程

```
git add <filename>

fit commit -m "提交信息"

git config --global user.email "you@example.com"
git config --global user.name "Your Name"

git remote add origin <server>　　//连接远程

git push origin master　　//推送
```


### 其他

* 让Git显示颜色

```
git config --global color.ui true
```

* 配置别名

```
git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"
```

## 进阶

### rebase

>git rebase  是将上游更改合并进本地仓库的通常方法，rebase 就好像是说「我想将我的更改建立在其他人的进展之上」

<mark>
☆rebase操作可以把本地未push的分叉提交历史整理成直线；
</mark>  

&nbsp;

<mark>
☆rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。
</mark>

&nbsp;

<mark>
☆在你工作流中使用 rebase 最好的用法之一就是清理本地正在开发的分支。隔一段时间执行一次交互式 rebase，你可以保证你 feature 分支中的每一个提交都是专注和有意义的。你在写代码时不用担心造成孤立的提交——因为你后面一定能修复。
</mark>

```
对最新的 3 次提交进行了交互式 rebase：
git checkout feature
git rebase -i HEAD~3

//交互式变基
git rebase -i　　
* pick：　　//正常选中
* reword：　　//选中，并且修改提交信息；
* edit：　　//选中，rebase时会暂停，允许你修改这个commit（参考这里）
* squash：　　//选中，会将当前commit与上一个commit合并
* fixup：　　//与squash相同，但不会保存当前commit的提交信息
* exec：　　//执行其他shell命令
```

### commit

```
//合并缓存的修改和上一次的提交，用新的快照替换上一个提交。缓存区没有文件时运行这个命令可以用来编辑上次提交的提交信息，而不会更改快照。
git commit --amend --no-edit

//自动将提交标记为先前提交的修复
git commit --fixup <commit>
```

### 撤销（revert）和重设（reset）对比

* git revert　　撤销一个已经提交的快照，保留项目历史，生成新的提交  
* git reset　　重设一个旧的提交，你不得不移除那个提交后的所有提交，再移除那个提交，然后重新提交后面的所有提交。


### checkout和reset对比

* git checkout　　移动指针检出一个旧版本
* git reset　　重设一个旧的提交，`--hard`移除之后的提交，`--soft`将之后的提交加入到缓冲区

## 分支
Git鼓励大量使用分支：

### 基本操作

* 查看分支：`git branch`
* 创建分支：`git branch <name>`
* 切换分支：`git checkout <name>  或者  git switch <name>`
* 创建+切换分支：`git checkout -b <name>  或者  git switch -c <name>`
* 合并某分支到当前分支：`git merge <name>`
* 删除分支：`git branch -d <name>`

### 其他    
* `git merge --no-ff -m "merge with no-ff" dev`　　//合并分支禁用Fast forward   
* `git checkout -b dev origin/dev`　　//创建远程origin的dev分支到本地    
* `git branch --set-upstream-to <branch-name> origin/<branch-name>`　　//本地分支和远程分支建立连接

* `git remote -v`　　//查看远程仓库
* `git remote rm origin`　　//删除已有的GitHub远程库

## Tag

* `git tag`　　可以查看所有标签
* `git tag <tagname>`　　新建一个标签，默认为HEAD，也可以指定一个commit id
* `git tag v0.9 f52c633`　　指定commit id
* `git tag -a <tagname> -m "blablabla..."`　　指定message

* `git push origin <tagname>`　　可以推送一个本地标签
* `git push origin --tags`　　可以推送全部未推送过的本地标签
* `git tag -d <tagname>`　　可以删除一个本地标签
* `git push origin :refs/tags/<tagname>`　　可以删除一个远程标签


## 暂存(stash) 

* `git stash`    
* `git stash list`　　查看
* `git stash apply stash@{0}`　　恢复
* `git stash drop`　　删除
* `git stash pop`　　恢复并删除

## bug

* `cherry-pick命令`　　复制一个特定的提交到当前分支
* `git cherry-pick 4c805e2`

## ignore

> https://github.com/github/gitignore

<mark>
检验.gitignore的标准是git status命令是不是说working directory clean
</mark>

* `git check-ignore -v App.class`    检查规则
* `git add -f App.class`    强制添加



## git fow 分支管理策略

>Git FLow模型定义了五种标准的分支  
主要分支，包括master分支和develop分支。  
辅助分支，包括feature分支，hotfix分支和release分支  

### 命令

* `git fow init`  初始化
* `git flow feature`  查看feature分支
* `git flow feature start feature_branch_name`  创建feature分支
* `git flow feature finish feature_branch_name`  自动合并feature分支到develop分支和master分支，并删除feature分支
* `git flow feature publish feature_branch_name`  push一个feature分支到远程仓库
* `git flow feature pull origin feature_branch_name`  pull一个feature分支到远程仓库

>[fit flow备忘清单](https://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html)

## 工作流

* git fow

* fork  

* feature

## ☆tips

<mark>
在master上修改代码，要像hotfix一样，创建分支然后分别合并，不然的话，master分支和dev分支的进度就不同步了。
</mark>